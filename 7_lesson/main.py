# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса
# (метод __init__()), который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц вы найдете в методичке.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно —
# первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.

# Задачу не понял, ход решения не понял, с чего начать к чему идти и как....искал решение в сети.
# и даже решения уже не могу толком адекватно прочесть и понять.
# Моего решения ниже нет, привожу 2 решения которые нашел в сети и комментариями пытаюсь понять их.
# Прошу мне помочь понять разобраться с этим, совсем не понимаю...
# Либо задача слищком сложная, либо я слишком глуп, не знаю, но уже прошел все стадии депрессии.

'''
class Matrix: # Создали клас
    def __init__(self, my_list): # сказали что ожидаем 1 параметр (для понимания назвали списком)
        self.my_list = my_list # присвоение

    # 3 способа на выбор, но все не понял...

    # первый способ
    def __str__(self): # __str__ - отвечает за то, что будет выводиться при вызове print(obj), верно?
        for row in self.my_list: # цикл по каждой строке масива \ цикл по каждому элементу списка
            for i in row: # цикл по каждому элементу строки \ цикл по каждому элементу внутреннего списка
                print(f"{i:4}", end="") # печатаем элемент строки, 4 пробела и перенос строки или что делает end? суть понял, но запись нет...а как в полном виде выглядит?
            print() # если убираю то в строку все идет, почему это делает перенос строки?
        return ''

    # второй способ
    #def __str__(self):
    #    return '\n'.join(map(str, self.my_list)) # все что писали выше можно вот так записать??? как читать понять =(
    # к сотому подходу понял. новая строка, добавляем числа (map) из списка. но почему str а не int?

    # третий способ
    #def __str__(self):
    #    return str('\n'.join(['\t'.join([str(el) for el in i]) for i in self.my_list])) # тоже не читаемо =(


    def __add__(self, other): # в этот метод прописываем как складывать элементы матриц
        for i in range(len(self.my_list)): # по каждому элементу, в диапазоне длины списка???
            for i_2 in range(len(other.my_list[i])): # тоже самое но в диапозоне длины второго списка?
                self.my_list[i][i_2] = self.my_list[i][i_2] + other.my_list[i][i_2] # итоговый элемент равен сумме эелементов двух объектов
        return Matrix.__str__(self) # вернуть итоговую матрицу


m = Matrix([[-1, 0, 1], [-1, 0, 1], [0, 1, -1], [1, 1, -1]]) 
new_m = Matrix([[-2, 0, 2], [-2, 0, 2], [0, 2, -2], [2, 2, -7]])
print(m.__add__(new_m)) # вызвали первая мтарица, испольуем прописанный метод сложения и ко второй матрице
'''

# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название.
# К типам одежды в этом проекте относятся пальто и костюм. У этих типов одежды существуют параметры:
# размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы:
# для пальто (V/6.5 + 0.5), для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани.
# Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.
'''
from abc import ABC, abstractmethod

class Clothes(ABC):

    def __init__(self, arg):
        self.arg = arg
        self.all_fiber = [] # тут будут все объемы

    @abstractmethod # сказали себе, что этот метод у потомков будет переопределяться
    def calc(self):
        pass

class Coat(Clothes):
    def calc(self):
        self.all_fiber.append(self.arg / 6.5 + 0.5) # занесли в список
        return f'Для пальто нужно: {self.arg / 6.5 + 0.5 :.2f} ткани'


class Costume(Clothes):
    def calc(self):
        self.all_fiber.append(2 * self.arg + 0.3)  # занесли в список
        return f'Для костюма нужно: {2 * self.arg + 0.3 :.2f} ткани'


coat = Coat(100)
costume = Costume(100)
print(coat.calc())
print(costume.calc())
# не понял как теперь вызвать общий объем...но не успеваю,бегу на некст задачу.
#print(Clothes.)
'''

# 3. Реализовать программу работы с органическими клетками.
# Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять
# увеличение, уменьшение, умножение и обычное (не целочисленное) деление клеток, соответственно.
# В методе деления должно осуществляться округление значения до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если
# разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.
'''
class Cell:
        def __init__(self, count):
            self.count = int(count)
        def __add__(self, other):
            return f'{self.count} клетка + {other.count} клетка = {self.count + other.count}'
        def __sub__(self, other):
            if self.count - other.count > 0 :
                return f'{self.count} клетка - {other.count} клетка = {self.count - other.count}'
            else:
                return f'{self.count} клетка - {other.count} клетка = исчезла'
        def __mul__(self, other):
            return f'{self.count} клетка * {other.count} клетка = {self.count * other.count}'
        def __truediv__(self, other):
            return f'{self.count} клетка / {other.count} клетка = {self.count // other.count}'
        #def make_order(self, counts): # признаюсь совсем не понял что нужно сделать, и не успева....

cell = Cell(1)
cell_2 = Cell(2)
cell_3 = Cell(9)
print(cell + cell_2)
print(cell - cell_2)
print(cell_3 - cell_2)
print(cell / cell_2)
print(cell_3 / cell_2)
print(cell * cell_2)
'''


